<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://www.burhanloey.com/' rel='self' type='application/rss+xml'/>
<title>
blog burhanloey
</title>
<link>
https://www.burhanloey.com/
</link>
<description>
burhanloey's blog
</description>
<lastBuildDate>
Sun, 27 May 2018 19:09:02 +0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2018-05-26-penggunaan-high-level-api-core-async/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2018-05-26-penggunaan-high-level-api-core-async/
</link>
<title>
Penggunaan high level API core.async
</title>
<description>
&lt;p&gt;&lt;img src=&quot;/blog/images/bruce_core_async.png&quot; alt=&quot;Tweet dari Bruce Hauman&quot; /&gt;&lt;/p&gt;&lt;p&gt;Semalam saya nampak Bruce Hauman ada &lt;a href='https://twitter.com/bhauman/status/1000070247863365632'&gt;tweet&lt;/a&gt; mengenai core.async. Macam tau-tau je saya pun tengah mula nak guna. Saya pun tengok video yang beliau tweet, &lt;a href='https://www.youtube.com/watch?v=096pIlA3GDo'&gt;video&lt;/a&gt; dari Timothy Baldridge yang menunjukkan bagaimana cara menggunakan core.async dalam situasi sebenar. Beliau pun perasan ramai yang buat silap termasuklah saya.&lt;/p&gt;&lt;p&gt;Dalam video tersebut, Timothy Baldridge sangat menggalakkan penggunaan function &lt;code&gt;pipeline&lt;/code&gt;. Sebelum ini saya masih tak faham waktu bila yang sesuai untuk menggunakan function tersebut. Saya pun tengoklah &lt;a href='https://clojure.github.io/core.async/'&gt;documentation&lt;/a&gt; core.async.&lt;/p&gt;&lt;p&gt;Dalam documentation tersebut, ada banyak lagi function yang bunyinya lebih kurang sama macam function untuk functional programming, antaranya map, reduce, merge, dan split. Saya pun go through documentation untuk semua function tersebut perlahan-lahan.&lt;/p&gt;&lt;p&gt;Semasa membaca documentation, saya perasan ada persamaan antara function-function tersebut, iaitu ayat yang berbunyi lebih kurang seperti ini:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; The channels will close after the source channel has closed. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Maksudnya kalau kita hanya menggunakan function-function high level tersebut untuk compose, sebaik sahaja kita &lt;code&gt;close!&lt;/code&gt; channel input, automatik channel-channel lain akan ditutup.&lt;/p&gt;&lt;p&gt;Berbeza dengan yang sebelum ini di mana saya terpaksa &lt;code&gt;close!&lt;/code&gt; channel satu per satu, dan secara jujurnya saya ada terlepas pandang untuk tutup beberapa channel.&lt;/p&gt;&lt;p&gt;Jadi, selepas refactor, code saya jadi begini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn- check-existing-user &amp;#91;&amp;#91;&amp;#95; form&amp;#93; out-ch&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; &amp;#91;&amp;#40;async/thread &amp;#40;users/find-user-by-username db-spec form&amp;#41;&amp;#41;
        &amp;#40;async/thread &amp;#40;users/find-user-by-email db-spec form&amp;#41;&amp;#41;&amp;#93;
       &amp;#40;async/merge&amp;#41;
       &amp;#40;async/reduce #&amp;#40;boolean &amp;#40;or %1 %2&amp;#41;&amp;#41; false&amp;#41;
       &amp;#40;async/pipeline 1 out-ch &amp;#40;map #&amp;#40;vector % form&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- generate-token &amp;#91;&amp;#93;
  &amp;#40;codecs/bytes-&amp;gt;hex &amp;#40;nonce/random-bytes 16&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- persist-user &amp;#91;&amp;#91;&amp;#95; user&amp;#93; out-ch&amp;#93;
  &amp;#40;let &amp;#91;prepared-user &amp;#40;-&amp;gt; user
                          &amp;#40;update :password hashers/derive&amp;#41;
                          &amp;#40;assoc :token &amp;#40;generate-token&amp;#41;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt;&amp;gt; &amp;#40;async/thread &amp;#40;users/register-user db-spec prepared-user&amp;#41;&amp;#41;
         &amp;#40;async/pipeline 1 out-ch &amp;#40;map #&amp;#40;vector &amp;#40;zero? %&amp;#41; prepared-user&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- split-if-error &amp;#91;ch&amp;#93;
  &amp;#40;async/split first ch&amp;#41;&amp;#41;

&amp;#40;defn register-handler &amp;#91;{:keys &amp;#91;params&amp;#93; :as req} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;input-ch                        &amp;#40;chan 1 &amp;#40;map v/validate-registration&amp;#41;&amp;#41;
        &amp;#91;invalid-ch valid-ch&amp;#93;           &amp;#40;split-if-error input-ch&amp;#41;
        availability-ch                 &amp;#40;chan&amp;#41;
        &amp;#91;not-available-ch available-ch&amp;#93; &amp;#40;split-if-error availability-ch&amp;#41;
        persisting-ch                   &amp;#40;chan&amp;#41;
        &amp;#91;failed-ch success-ch&amp;#93;          &amp;#40;split-if-error persisting-ch&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt;&amp;gt; valid-ch
         &amp;#40;async/pipeline-async 1 availability-ch check-existing-user&amp;#41;&amp;#41;
    &amp;#40;-&amp;gt;&amp;gt; available-ch
         &amp;#40;async/pipeline-async 1 persisting-ch persist-user&amp;#41;&amp;#41;

    &amp;#40;put! input-ch params&amp;#41;

    &amp;#40;go
      &amp;#40;respond
       &amp;#40;alt!
         invalid-ch
         &amp;#40;&amp;#91;result&amp;#93; &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                       &amp;#40;flash {:errors &amp;#40;first result&amp;#41; :data &amp;#40;second result&amp;#41;}&amp;#41;&amp;#41;&amp;#41;

         not-available-ch
         &amp;#40;&amp;#91;&amp;#93;       &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                       &amp;#40;flash {:message &amp;#40;:user-existed msg&amp;#41;}&amp;#41;&amp;#41;&amp;#41;

         failed-ch
         &amp;#40;&amp;#91;&amp;#93;       &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                       &amp;#40;flash {:message &amp;#40;:failed msg&amp;#41;}&amp;#41;&amp;#41;&amp;#41;

         success-ch
         &amp;#40;&amp;#91;result&amp;#93; &amp;#40;do
                     &amp;#40;future &amp;#40;mailer/send-email-verification &amp;#40;second result&amp;#41;&amp;#41;&amp;#41;
                     &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
                         &amp;#40;flash {:message &amp;#40;:success msg&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;close! input-ch&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Jika diperhatikan, saya hanya menggunakan satu block go sahaja. Tiada langsung take (&lt;code&gt;&amp;lt;!&lt;/code&gt;) atau put (&lt;code&gt;&amp;gt;!&lt;/code&gt;). Saya juga hanya perlu &lt;code&gt;close!&lt;/code&gt; satu channel sahaja selepas selesai menghantar response. Error handling juga saya bawa sehingga ke bahagian akhir sekali, jadi tiada &lt;em&gt;side-effect&lt;/em&gt;.&lt;/p&gt;
</description>
<pubDate>
Sat, 26 May 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2018-05-25-sekali-lagi-silap-mengenai-core-async/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2018-05-25-sekali-lagi-silap-mengenai-core-async/
</link>
<title>
Sekali lagi silap mengenai core.async
</title>
<description>
&lt;p&gt;Sekali lagi saya salah mengenai core.async dalam post saya yang lepas.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Secara ringkasnya cara yang betul ialah yang mula-mula di mana saya  menggunakan transducer. Cara yang salah ialah yang di mana saya menggunakan  pub sub (yang saya sangkakan betul). &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Semalam saya tidak berpuas hati dengan code untuk pub sub, sebab perlu tulis terlalu panjang. Takkanlah perlu tulis code seperti itu walaupun untuk buat benda yang remeh. Saya pun baca-bacalah mengenai core.async, async vs. sync, dan motivasi di sebalik setiap paradigm.&lt;/p&gt;&lt;p&gt;Bila sebut tentang concurrency, masalahnya bukan mengenai bagaimana untuk menjalankan code secara parallel (serentak), tetapi mengenai bagaimana untuk menyatukan kembali data-data yang telah dihantar ke thread-thread yang berlainan.&lt;/p&gt;&lt;p&gt;Antara teknik yang selalu kita dengar apabila sebut tentang asynchronous ialah callback atau event-driven. Jadi ada paradigm seperti future/promise untuk mengelakkan callback hell. Paradigm untuk core.async adalah seperti BlockingQueue. Saya pun baca mengenai rationale di sebalik design core.async.&lt;/p&gt;&lt;p&gt;Yang saya faham, tujuan core.async adalah supaya kita boleh menulis code seperti synchronous tetapi di sebalik tabir, code akan berjalan secara asynchronous. Contohnya, apabila kita menggunakan take (&lt;code&gt;&amp;lt;!&lt;/code&gt;) dalam block go, dalam kepala kita, kita rasakan seperti itu operasi blocking, tetapi di sebalik tabir, program menulis callback untuk sambung semula proses apabila channel tersebut dah ready.&lt;/p&gt;&lt;p&gt;Untuk meyakinkan diri saya, saya tulis code yang sama untuk server Netty iaitu http-kit untuk bandingkan dengan server Jetty yang saya guna sebelum ini. Kalau load testing menunjukkan request per second untuk Netty lebih tinggi daripada Jetty bermakna saya betul, kalau sama bermakna code saya salah.&lt;/p&gt;&lt;p&gt;Hasilnya,&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Code transducer untuk Jetty: 3500+ req/s
Code transducer untuk Netty: 8000+ req/s
Code pub/sub untuk Jetty: 2000+ req/s
Code pub/sub untuk Netty: 2000+ req/s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Apa yang berlaku dalam code pub/sub ialah semua request perlu melalui satu channel sahaja. Saya dengan tidak sengaja telah mengubah multithreaded server menjadi single-threaded, asynchronous server. Aduh.&lt;/p&gt;&lt;p&gt;Dari segi masa response, page untuk code pub/sub load lebih laju, tetapi setiap kali saya request page, req/s jatuh ke 1500+. Untuk code transducer, masa untuk load page dalam 1-2 saat, tetapi req/s tak jatuh-jatuh.&lt;/p&gt;&lt;p&gt;Sekarang dah yakin bahawa code transducer adalah yang betul. Cuma ada sedikit kekurangan. Dalam code tersebut, saya terlupa untuk tutup channel selepas menghantar response. Selepas sedikit refactor, code jadi begini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn- validate-form &amp;#91;&amp;#91;response-chan form&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;form-chan &amp;#40;chan&amp;#41;&amp;#93;
    &amp;#40;go
      &amp;#40;let &amp;#91;&amp;#91;errors &amp;#95;&amp;#93; &amp;#40;v/validate-registration form&amp;#41;
            valid? &amp;#40;not errors&amp;#41;&amp;#93;
        &amp;#40;if valid?
          &amp;#40;&amp;gt;! form-chan form&amp;#41;
          &amp;#40;do
            &amp;#40;close! form-chan&amp;#41;
            &amp;#40;&amp;gt;! response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                  &amp;#40;flash {:errors errors :data form}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#91;response-chan form-chan&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn- check-existing-user &amp;#91;&amp;#91;response-chan form-chan&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;user-chan &amp;#40;chan&amp;#41;&amp;#93;
    &amp;#40;go
      &amp;#40;if-let &amp;#91;form &amp;#40;&amp;lt;! form-chan&amp;#41;&amp;#93;
        &amp;#40;let &amp;#91;username-existed &amp;#40;thread &amp;#40;users/find-user-by-username db-spec form&amp;#41;&amp;#41;
              email-existed &amp;#40;thread &amp;#40;users/find-user-by-email db-spec form&amp;#41;&amp;#41;
              available? &amp;#40;not &amp;#40;or &amp;#40;&amp;lt;! username-existed&amp;#41;
                                  &amp;#40;&amp;lt;! email-existed&amp;#41;&amp;#41;&amp;#41;&amp;#93;
          &amp;#40;if available?
            &amp;#40;&amp;gt;! user-chan form&amp;#41;
            &amp;#40;do
              &amp;#40;close! user-chan&amp;#41;
              &amp;#40;&amp;gt;! response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                    &amp;#40;flash {:message &amp;#40;:user-existed msg&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;close! user-chan&amp;#41;&amp;#41;&amp;#41;
    &amp;#91;response-chan user-chan&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn- persist-user &amp;#91;&amp;#91;response-chan user-chan&amp;#93;&amp;#93;
  &amp;#40;go
    &amp;#40;when-let &amp;#91;user &amp;#40;&amp;lt;! user-chan&amp;#41;&amp;#93;
      &amp;#40;let &amp;#91;email-verification-token &amp;#40;codecs/bytes-&amp;gt;hex &amp;#40;nonce/random-bytes 16&amp;#41;&amp;#41;
            prepared-user &amp;#40;-&amp;gt; user
                              &amp;#40;update :password hashers/derive&amp;#41;
                              &amp;#40;assoc :token email-verification-token&amp;#41;&amp;#41;
            success? &amp;#40;-&amp;gt;&amp;gt; &amp;#40;thread &amp;#40;users/register-user db-spec prepared-user&amp;#41;&amp;#41;
                          &amp;lt;!
                          pos?&amp;#41;&amp;#93;
        &amp;#40;if success?
          &amp;#40;do
            &amp;#40;future &amp;#40;mailer/send-email-verification user&amp;#41;&amp;#41;
            &amp;#40;&amp;gt;! response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
                                  &amp;#40;flash {:message &amp;#40;:success msg&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;
          &amp;#40;&amp;gt;! response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                &amp;#40;flash {:message &amp;#40;:failed msg&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn register-handler &amp;#91;{:keys &amp;#91;params&amp;#93; :as req} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;response-chan &amp;#40;chan&amp;#41;
        form &amp;#40;select-keys params &amp;#91;:username :email :password&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;go
      &amp;#40;-&amp;gt;&amp;gt; &amp;#91;response-chan form&amp;#93;
           validate-form
           check-existing-user
           persist-user&amp;#41;&amp;#41;
    &amp;#40;go
      &amp;#40;respond &amp;#40;&amp;lt;! response-chan&amp;#41;&amp;#41;
      &amp;#40;close! response-chan&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Code yang terbaharu ini lain sedikit daripada yang transducer sebab dulu saya kurang faham tujuan block go. Penggunaan transducer sama sahaja dengan thread-last macro &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; yang saya gunakan di sini.&lt;/p&gt;&lt;p&gt;Kalau saya tidak tutup channel, takut lama-lama server akan ada software rot.&lt;/p&gt;&lt;p&gt;Dengan code yang baru ini, server Jetty mampu capai 4200+ req/s. Mungkin sebab kurang channel ataupun sebab saya tutup channel.&lt;/p&gt;&lt;p&gt;Apa-apa pun sekarang saya sangat berpuas hati sebab boleh buat server (http-kit) sama performance dengan Play Framework, framework yang saya guna di tempat kerja yang lepas.&lt;/p&gt;
</description>
<pubDate>
Fri, 25 May 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2018-05-23-pembetulan-post-lepas-mengenai-core-async/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2018-05-23-pembetulan-post-lepas-mengenai-core-async/
</link>
<title>
Pembetulan post lepas mengenai core.async
</title>
<description>
&lt;p&gt;Post yang &lt;a href='/blog/posts/2018-05-21-refactor-core-async-menggunakan-transducer/'&gt;lepas&lt;/a&gt; ada kesilapan yang sangat kritikal. Cara penggunaan transducer dengan core.async tidak salah. Yang salahnya ialah saya create semua &lt;code&gt;chan&lt;/code&gt; yang untuk process untuk setiap request. Maksudnya tak ada beza sama ada saya tulis secara synchronous ataupun asynchronous.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Load testing yang menunjukkan server Java mampu untuk handle request walaupun  banyak silap yang saya buat menunjukkan betapa hebatnya Java Virtual Machine. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Semalam saya tengok &lt;a href='http://www.youtube.com/watch?v=enwIIGzhahw'&gt;talk&lt;/a&gt; dari Timothy Baldridge mengenai core.async. Yang membuatkan saya sedar yang saya silap apabila beliau bercakap mengenai &lt;a href='https://clojuredocs.org/clojure.core.async/mult'&gt;mult&lt;/a&gt;. Function &lt;code&gt;mult&lt;/code&gt; itulah yang saya tercari-cari.&lt;/p&gt;&lt;p&gt;Satu lagi yang saya terlepas pandang ialah &lt;a href='https://clojuredocs.org/clojure.core.async/go-loop'&gt;go-loop&lt;/a&gt;. Clojure menyediakan &lt;code&gt;go-loop&lt;/code&gt; hanya untuk membuatkan loop di dalam block go. Maksudnya cara tersebut selalu diguna pakai sehingga mereka memerlukan macro untuk proses tersebut. Saya selalu dengar mengenai &lt;code&gt;event loop&lt;/code&gt; setiap kali berbincang mengenai asynchronous. Jadi, &lt;code&gt;go-loop&lt;/code&gt; tersebut samalah seperti &lt;code&gt;event loop&lt;/code&gt; untuk dispatch dari channel ke channel.&lt;/p&gt;&lt;p&gt;Maka saya pun tulis semula code tersebut menggunakan &lt;code&gt;go-loop&lt;/code&gt; dan &lt;code&gt;mult&lt;/code&gt;. Hasilnya,&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def register-response-chan &amp;#40;chan&amp;#41;&amp;#41;


&amp;#40;def validate-chan &amp;#40;chan 1 &amp;#40;map v/validate-registration&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def valid-form-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def valid-form-mult &amp;#40;mult valid-form-chan&amp;#41;&amp;#41;

&amp;#40;go-loop &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;errors form&amp;#93; &amp;#40;&amp;lt;! validate-chan&amp;#41;&amp;#93;
    &amp;#40;if errors
      &amp;#40;&amp;gt;! register-response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                     &amp;#40;flash {:errors errors :data form}&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;&amp;gt;! valid-form-chan form&amp;#41;&amp;#41;
    &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;


&amp;#40;def username-existed-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def email-existed-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def user-existed-chan &amp;#40;chan&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan 1&amp;#41;&amp;#93;
  &amp;#40;tap valid-form-mult c&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;user &amp;#40;&amp;lt;!! c&amp;#41;&amp;#93;
        &amp;#40;&amp;gt;!! username-existed-chan
             &amp;#40;boolean &amp;#40;users/find-user-by-username db-spec user&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap valid-form-mult c&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;user &amp;#40;&amp;lt;!! c&amp;#41;&amp;#93;
        &amp;#40;&amp;gt;!! email-existed-chan
             &amp;#40;boolean &amp;#40;users/find-user-by-email db-spec user&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;go-loop &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;username-existed &amp;#40;&amp;lt;! username-existed-chan&amp;#41;
        email-existed &amp;#40;&amp;lt;! email-existed-chan&amp;#41;&amp;#93;
    &amp;#40;&amp;gt;! user-existed-chan &amp;#40;or username-existed email-existed&amp;#41;&amp;#41;
    &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;


&amp;#40;def register-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def register-mult &amp;#40;mult register-chan&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap valid-form-mult c&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;user-existed &amp;#40;&amp;lt;! user-existed-chan&amp;#41;&amp;#93;
      &amp;#40;if user-existed
        &amp;#40;&amp;gt;! register-response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                       &amp;#40;flash {:message user-existed-msg}&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;&amp;gt;! register-chan &amp;#40;&amp;lt;! c&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;


&amp;#40;def hashed-password-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def email-verification-token-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def prepared-user-chan &amp;#40;chan&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap register-mult c&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;password&amp;#93;} &amp;#40;&amp;lt;!! c&amp;#41;&amp;#93;
        &amp;#40;&amp;gt;!! hashed-password-chan &amp;#40;hashers/derive password&amp;#41;&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap register-mult c&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;&amp;lt;! c&amp;#41;
    &amp;#40;&amp;gt;! email-verification-token-chan &amp;#40;-&amp;gt; &amp;#40;nonce/random-bytes 16&amp;#41;
                                          &amp;#40;codecs/bytes-&amp;gt;hex&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap register-mult c&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;user &amp;#40;&amp;lt;! c&amp;#41;
          password &amp;#40;&amp;lt;! hashed-password-chan&amp;#41;
          token &amp;#40;&amp;lt;! email-verification-token-chan&amp;#41;&amp;#93;
      &amp;#40;&amp;gt;! prepared-user-chan &amp;#40;assoc user :password password :token token&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;


&amp;#40;def persisted-user-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def persisted-user-mult &amp;#40;mult persisted-user-chan&amp;#41;&amp;#41;

&amp;#40;async/thread
  &amp;#40;loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;user &amp;#40;&amp;lt;!! prepared-user-chan&amp;#41;
          row-count &amp;#40;users/register-user db-spec user&amp;#41;&amp;#93;
      &amp;#40;if &amp;#40;zero? row-count&amp;#41;
        &amp;#40;&amp;gt;!! register-response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                        &amp;#40;flash {:message failed-msg}&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;&amp;gt;!! persisted-user-chan user&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap persisted-user-mult c&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;user &amp;#40;&amp;lt;!! c&amp;#41;&amp;#93;
        &amp;#40;mailer/send-email-verification user&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;c &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;tap persisted-user-mult c&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;&amp;lt;! c&amp;#41;
    &amp;#40;&amp;gt;! register-response-chan &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
                                   &amp;#40;flash success-msg&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn register &amp;#91;{:keys &amp;#91;params&amp;#93;} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;form &amp;#40;select-keys params &amp;#91;:username :email :password&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;put! validate-chan form&amp;#41;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;res &amp;#95;&amp;#93; &amp;#40;alts! &amp;#91;register-response-chan &amp;#40;timeout 10000&amp;#41;&amp;#93;&amp;#41;&amp;#93;
          &amp;#40;respond res&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tengok function untuk handler yang bawah sekali boleh nampak dia takde create channel atau thread yang baru, tugas dia hanya masukkan data ke channel yang mula-mula iaitu &lt;code&gt;validate-chan&lt;/code&gt; kemudian tunggu response dari &lt;code&gt;register-response-chan&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Kalau sesiapa yang mula dengar pasal &lt;code&gt;go loop&lt;/code&gt; mungkin akan ingat, &quot;Eh, takpe ke buat banyak-banyak loop? Tak makan CPU ke nanti?&quot;. Jawapannya, sebab block go ialah sebuah macro. Apabila kita buat panggilan &lt;code&gt;&amp;gt;!&lt;/code&gt; atau &lt;code&gt;&amp;lt;!&lt;/code&gt; dia bukannya block, tetapi parking. Kalau tengok code untuk macro go, di dalamnya ada macam state machine. Senang cerita jangan risau pasal performance.&lt;/p&gt;&lt;p&gt;Jadi, tengok balik code yang baru di atas, kalau sekali pandang macam nak muntah. Berterabur saya letak channel. Waktu saya menulis code tersebut, saya rasa macam saya sedang menulis code pub/sub atau reactive programming. Saya pun google 'core.async pub/sub'. Lahaii, memang ada. &lt;a href='https://github.com/clojure/core.async/wiki/Pub-Sub'&gt;Pub/sub&lt;/a&gt; merupakan cara yang lebih high level untuk menggantikan penggunaan &lt;code&gt;mult&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Selepas refactor, code jadi begini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def pub-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;def publication &amp;#40;pub pub-chan :msg-type&amp;#41;&amp;#41;

&amp;#40;def response-chan &amp;#40;chan&amp;#41;&amp;#41;
&amp;#40;sub publication :response response-chan&amp;#41;

&amp;#40;let &amp;#91;raw-input-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :raw-input raw-input-chan&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;{:keys &amp;#91;form&amp;#93;} &amp;#40;&amp;lt;! raw-input-chan&amp;#41;
          &amp;#91;errors valid-form&amp;#93; &amp;#40;v/validate-registration form&amp;#41;&amp;#93;
      &amp;#40;if errors
        &amp;#40;&amp;gt;! pub-chan {:msg-type :response
                      :response &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                    &amp;#40;flash {:errors errors :data form}&amp;#41;&amp;#41;}&amp;#41;
        &amp;#40;&amp;gt;! pub-chan {:msg-type :valid-form :form valid-form}&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;valid-form-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :valid-form valid-form-chan&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;form&amp;#93;} &amp;#40;&amp;lt;!! valid-form-chan&amp;#41;
            existing-username &amp;#40;users/find-user-by-username db-spec form&amp;#41;&amp;#93;
        &amp;#40;&amp;gt;!! pub-chan
             {:msg-type :existing-username :existing-username existing-username}&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;valid-form-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :valid-form valid-form-chan&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;form&amp;#93;} &amp;#40;&amp;lt;!! valid-form-chan&amp;#41;
            existing-email &amp;#40;users/find-user-by-email db-spec form&amp;#41;&amp;#93;
        &amp;#40;&amp;gt;!! pub-chan {:msg-type :existing-email :existing-email existing-email}&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;existing-username-chan &amp;#40;chan&amp;#41;
      existing-email-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :existing-username existing-username-chan&amp;#41;
  &amp;#40;sub publication :existing-email existing-email-chan&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;{:keys &amp;#91;existing-username&amp;#93;} &amp;#40;&amp;lt;! existing-username-chan&amp;#41;
          {:keys &amp;#91;existing-email&amp;#93;} &amp;#40;&amp;lt;! existing-email-chan&amp;#41;
          user-existed &amp;#40;boolean &amp;#40;or existing-username existing-email&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;&amp;gt;! pub-chan {:msg-type :whether-user-existed :user-existed user-existed}&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;whether-user-existed-chan &amp;#40;chan&amp;#41;
      valid-form-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :whether-user-existed whether-user-existed-chan&amp;#41;
  &amp;#40;sub publication :valid-form valid-form-chan&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;{:keys &amp;#91;user-existed&amp;#93;} &amp;#40;&amp;lt;! whether-user-existed-chan&amp;#41;
          {:keys &amp;#91;form&amp;#93;} &amp;#40;&amp;lt;! valid-form-chan&amp;#41;&amp;#93;
      &amp;#40;if user-existed
        &amp;#40;&amp;gt;! pub-chan {:msg-type :response
                      :response &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                    &amp;#40;flash {:message user-existed-msg}&amp;#41;&amp;#41;}&amp;#41;
        &amp;#40;&amp;gt;! pub-chan {:msg-type :new-user :user form}&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;new-user-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :new-user new-user-chan&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;password&amp;#93;} &amp;#40;:user &amp;#40;&amp;lt;!! new-user-chan&amp;#41;&amp;#41;
            hashed-password &amp;#40;hashers/derive password&amp;#41;&amp;#93;
        &amp;#40;&amp;gt;!! pub-chan {:msg-type :hashed-password :password hashed-password}&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;new-user-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :new-user new-user-chan&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;&amp;lt;! new-user-chan&amp;#41;
    &amp;#40;let &amp;#91;token &amp;#40;codecs/bytes-&amp;gt;hex &amp;#40;nonce/random-bytes 16&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;&amp;gt;! pub-chan {:msg-type :email-verification-token :token token}&amp;#41;&amp;#41;
    &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;hashed-password-chan &amp;#40;chan&amp;#41;
      email-verification-token-chan &amp;#40;chan&amp;#41;
      new-user-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :hashed-password hashed-password-chan&amp;#41;
  &amp;#40;sub publication :email-verification-token email-verification-token-chan&amp;#41;
  &amp;#40;sub publication :new-user new-user-chan&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;{:keys &amp;#91;user&amp;#93;} &amp;#40;&amp;lt;! new-user-chan&amp;#41;
          {:keys &amp;#91;password&amp;#93;} &amp;#40;&amp;lt;! hashed-password-chan&amp;#41;
          {:keys &amp;#91;token&amp;#93;} &amp;#40;&amp;lt;! email-verification-token-chan&amp;#41;
          prepared-user &amp;#40;assoc user :password password :token token&amp;#41;&amp;#93;
      &amp;#40;&amp;gt;! pub-chan {:msg-type :prepared-user :user prepared-user}&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;prepared-user-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :prepared-user prepared-user-chan&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;user&amp;#93;} &amp;#40;&amp;lt;!! prepared-user-chan&amp;#41;
            row-count &amp;#40;users/register-user db-spec user&amp;#41;&amp;#93;
        &amp;#40;if &amp;#40;zero? row-count&amp;#41;
          &amp;#40;&amp;gt;!! pub-chan {:msg-type :response
                         :response &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                                       &amp;#40;flash {:message failed-msg}&amp;#41;&amp;#41;}&amp;#41;
          &amp;#40;&amp;gt;!! pub-chan {:msg-type :persisted-user :user user}&amp;#41;&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;persisted-user-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :persisted-user persisted-user-chan&amp;#41;
  &amp;#40;async/thread
    &amp;#40;loop &amp;#91;&amp;#93;
      &amp;#40;let &amp;#91;{:keys &amp;#91;user&amp;#93;} &amp;#40;&amp;lt;!! persisted-user-chan&amp;#41;&amp;#93;
        &amp;#40;mailer/send-email-verification user&amp;#41;
        &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;persisted-user-chan &amp;#40;chan&amp;#41;&amp;#93;
  &amp;#40;sub publication :persisted-user persisted-user-chan&amp;#41;
  &amp;#40;go-loop &amp;#91;&amp;#93;
    &amp;#40;&amp;lt;! persisted-user-chan&amp;#41;
    &amp;#40;&amp;gt;! pub-chan {:msg-type :response
                  :response &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
                                &amp;#40;flash success-msg&amp;#41;&amp;#41;}&amp;#41;
    &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn register &amp;#91;{:keys &amp;#91;params&amp;#93;} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;form &amp;#40;select-keys params &amp;#91;:username :email :password&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;res &amp;#95;&amp;#93; &amp;#40;alts! &amp;#91;response-chan &amp;#40;timeout 10000&amp;#41;&amp;#93;&amp;#41;&amp;#93;
          &amp;#40;respond &amp;#40;:response res&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;put! pub-chan {:msg-type :raw-input :form form}&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Akhirnya code tersebut jadi lebih kurang sama sahaja seperti penggunaan library RxJava atau pub/sub yang lain.&lt;/p&gt;&lt;p&gt;Satu trick yang saya suka buat, saya letakkan transducer untuk log data yang lalu ikut channel publisher. Dengan mudah dapat log semua event hanya dengan menukar satu line.&lt;/p&gt;
</description>
<pubDate>
Wed, 23 May 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2018-05-21-refactor-core-async-menggunakan-transducer/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2018-05-21-refactor-core-async-menggunakan-transducer/
</link>
<title>
Refactor code core.async menggunakan Transducer
</title>
<description>
 &lt;blockquote&gt;&lt;p&gt; Artikel ini banyak silap, sila ke &lt;a href='/blog/posts/2018-05-23-pembetulan-post-lepas-mengenai-core-async/'&gt;post&lt;/a&gt; seterusnya untuk pembetulan. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Dulu saya hanya menulis code Clojure secara &lt;em&gt;synchronous&lt;/em&gt;, dan hanya pindahkan code ke &lt;em&gt;thread&lt;/em&gt; lain bila perlu. Baru-baru ini saya jenguk-jenguk code untuk &lt;a href='https://github.com/ring-clojure/ring'&gt;Ring&lt;/a&gt;, dan saya mula perasan setiap &lt;em&gt;middleware&lt;/em&gt; mengambil dua jenis function, satu function 1-&lt;em&gt;arity&lt;/em&gt; yang biasa, satu lagi function 3-&lt;em&gt;arity&lt;/em&gt;. Saya pun tertanya-tanya apa guna function 3-&lt;em&gt;arity&lt;/em&gt; ni.&lt;/p&gt;&lt;p&gt;Lepas check, rupa-rupanya function 3-&lt;em&gt;arity&lt;/em&gt; itu adalah untuk &lt;em&gt;async handler&lt;/em&gt;. Server Clojure yang lain memang dah boleh handle &lt;em&gt;async request&lt;/em&gt;, contohnya &lt;a href='https://github.com/ztellman/aleph'&gt;Aleph&lt;/a&gt; dan &lt;a href='https://github.com/http-kit/http-kit'&gt;http-kit&lt;/a&gt;, tapi saya tak suka guna sebab tak ikut standard Ring. Server default untuk Ring ialah Jetty. Versi Jetty yang latest dah ikut spec Servlet 3.1, jadi dah boleh handle &lt;em&gt;async request&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Jadi, untuk enable function 3-&lt;em&gt;arity&lt;/em&gt;, kalau menggunakan &lt;a href='https://github.com/weavejester/lein-ring'&gt;lein-ring&lt;/a&gt;, cuma perlu set option &lt;code&gt;:async?&lt;/code&gt; ke &lt;code&gt;true&lt;/code&gt;. Kemudian tukar handler dari,&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn hello-handler &amp;#91;req&amp;#93;
  {:status 200
   :headers {}
   :body &amp;quot;Hello&amp;quot;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ke&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn hello-handler &amp;#91;req respond raise&amp;#93;
  &amp;#40;respond {:status 200
            :headers {}
            :body &amp;quot;Hello&amp;quot;}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Maksudnya kalau kita panggil function &lt;code&gt;respond&lt;/code&gt; dari mana-mana thread pun, dia akan terus bagi response. Tak perlu guna blocking call dah.&lt;/p&gt;&lt;p&gt;Maka saya pun cubalah menulis handler menggunakan &lt;a href='https://github.com/clojure/core.async'&gt;core.async&lt;/a&gt;. Konsep &lt;code&gt;core.async&lt;/code&gt; sama sahaja dengan konsep concurrency dalam programming language Go.&lt;/p&gt;&lt;p&gt;Ini cubaan pertama:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn register &amp;#91;{:keys &amp;#91;params&amp;#93;} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;form &amp;#40;select-keys params &amp;#91;:username :email :password&amp;#93;&amp;#41;
        validated &amp;#40;chan&amp;#41;
        user &amp;#40;chan&amp;#41;
        new-user &amp;#40;chan&amp;#41;
        hashed &amp;#40;chan&amp;#41;
        result &amp;#40;chan&amp;#41;&amp;#93;
    &amp;#40;go &amp;#40;&amp;gt;! validated &amp;#40;v/validate-registration form&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors data&amp;#93; &amp;#40;&amp;lt;! validated&amp;#41;&amp;#93;
          &amp;#40;if errors
            &amp;#40;&amp;gt;! result &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                           &amp;#40;flash {:errors errors
                                   :data data}&amp;#41;&amp;#41;&amp;#41; ; assoc previous data
            &amp;#40;&amp;gt;! user data&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;let &amp;#91;u           &amp;#40;&amp;lt;! user&amp;#41;
              by-username &amp;#40;async/thread &amp;#40;find-user-by-username &amp;#40;:username u&amp;#41;&amp;#41;&amp;#41;
              by-email    &amp;#40;async/thread &amp;#40;find-user-by-email &amp;#40;:email u&amp;#41;&amp;#41;&amp;#41;&amp;#93;
          &amp;#40;if &amp;#40;or &amp;#40;&amp;lt;! by-username&amp;#41; &amp;#40;&amp;lt;! by-email&amp;#41;&amp;#41;
            &amp;#40;&amp;gt;! result &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
                           &amp;#40;flash {:message &amp;quot;Username/email sudah diambil. Sila daftar menggunakan username/email yang lain.&amp;quot;}&amp;#41;&amp;#41;&amp;#41;
            &amp;#40;&amp;gt;! new-user u&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;&amp;gt;! hashed &amp;#40;update &amp;#40;&amp;lt;! new-user&amp;#41; :password hashers/derive&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;&amp;lt;! hashed&amp;#41;
        &amp;#40;&amp;gt;! result &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
                       &amp;#40;flash &amp;quot;Anda sudah berjaya mendaftar. Sila log masuk .&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;res &amp;#95;&amp;#93; &amp;#40;alts! &amp;#91;result &amp;#40;timeout 10000&amp;#41;&amp;#93;&amp;#41;&amp;#93;
          &amp;#40;respond res&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ambik kau. Buruk nak mampus. Jalan memang jalan code-nya, logic semua ok, tapi dah takde rupa functional programming.&lt;/p&gt;&lt;p&gt;Jadi, saya tengok balik &lt;a href='https://clojuredocs.org/clojure.core.async/chan'&gt;documentation&lt;/a&gt; untuk &lt;code&gt;chan&lt;/code&gt;, saya perasan ada parameter &lt;code&gt;xform&lt;/code&gt;. Eh?!&lt;/p&gt;&lt;p&gt;Saya tahu guna core.async, saya tahu guna transducer, tapi tak tahu pulak boleh guna core.async dengan transducer sama-sama.&lt;/p&gt;&lt;p&gt;Selepas refactor, code jadi begini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def user-existed-msg &amp;quot;Username/email sudah diambil. Sila daftar menggunakan username/email yang lain.&amp;quot;&amp;#41;
&amp;#40;def success-msg &amp;quot;Anda sudah berjaya mendaftar. Sila log masuk .&amp;quot;&amp;#41;

&amp;#40;defn- make-flash-msg &amp;#91;&amp;#91;errors data&amp;#93;&amp;#93;
  &amp;#40;if errors
    &amp;#91;{:errors errors :data data} data&amp;#93;
    &amp;#91;nil data&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn- hash-user-password &amp;#91;&amp;#91;errors user :as all&amp;#93;&amp;#93;
  &amp;#40;if errors
    all
    &amp;#91;errors &amp;#40;update user :password hashers/derive&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn- make-response &amp;#91;&amp;#91;errors &amp;#95;&amp;#93;&amp;#93;
  &amp;#40;if errors
    &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
        &amp;#40;flash errors&amp;#41;&amp;#41;
    &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
        &amp;#40;flash success-msg&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def validate-xform
  &amp;#40;comp
   &amp;#40;map v/validate-registration&amp;#41;
   &amp;#40;map make-flash-msg&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def register-xform
  &amp;#40;comp
   &amp;#40;map hash-user-password&amp;#41;
   ;; TODO: Add one more function here in the middle to persist user
   &amp;#40;map make-response&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn register &amp;#91;{:keys &amp;#91;params&amp;#93;} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;validated &amp;#40;chan 1 validate-xform&amp;#41;
        result &amp;#40;chan 1 register-xform&amp;#41;&amp;#93;
    &amp;#40;go &amp;#40;&amp;gt;! validated &amp;#40;select-keys params &amp;#91;:username :email :password&amp;#93;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors user :as all&amp;#93; &amp;#40;&amp;lt;! validated&amp;#41;&amp;#93;
          &amp;#40;cond
            ;; If already has errors, skip checking for existing user.
            errors &amp;#40;&amp;gt;! result all&amp;#41;
            ;; Check for existing user with same username or email.
            &amp;#40;or &amp;#40;&amp;lt;! &amp;#40;async/thread &amp;#40;find-user-by-username &amp;#40;:username user&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                &amp;#40;&amp;lt;! &amp;#40;async/thread &amp;#40;find-user-by-email &amp;#40;:email user&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
            &amp;#40;&amp;gt;! result &amp;#91;{:message user-existed-msg} user&amp;#93;&amp;#41;
            ;; Return same data if there is no problem.
            :else &amp;#40;&amp;gt;! result all&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;res &amp;#95;&amp;#93; &amp;#40;alts! &amp;#91;result &amp;#40;timeout 10000&amp;#41;&amp;#93;&amp;#41;&amp;#93;
          &amp;#40;respond res&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sekarang barulah pendek-pendek function tersebut.&lt;/p&gt;&lt;p&gt;Beza dengan yang asal ialah yang asal saya terus bagi result sebaik sahaja ada error. Orang panggil &lt;em&gt;short circuit&lt;/em&gt;. Masalah dengan cara tersebut ialah cara tersebut merupakan &lt;em&gt;side-effect&lt;/em&gt;. &lt;em&gt;Side-effect&lt;/em&gt; sangat tidak digalakkan dalam functional programming.&lt;/p&gt;&lt;p&gt;Jadi, saya tukar kepada menggunakan konsep monad. Saya jadikan function-function untuk &lt;code&gt;xform&lt;/code&gt; supaya return sebuah vector di mana item pertama ialah error dan item kedua ialah data sebenar yang perlu return. Error tersebut akan diselesaikan di pengakhiran iaitu dalam function &lt;code&gt;make-response&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Gambar ini mungkin lebih jelas:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/blog/images/monad.png&quot; alt=&quot;Gambar menunjukkan konsep monad&quot; /&gt;&lt;/p&gt;&lt;p&gt;Masalah yang tinggal sekarang ialah panggilan ke &lt;code&gt;async/thread&lt;/code&gt; untuk &lt;code&gt;find-user-by-username&lt;/code&gt; dan &lt;code&gt;find-user-by-email&lt;/code&gt;. Masalahnya sebab saya tidak boleh panggil &lt;code&gt;&amp;lt;!&lt;/code&gt; di luar block &lt;code&gt;go&lt;/code&gt;. Kalau boleh, bolehlah saya letak bahagian tersebut sebagai xform.&lt;/p&gt;&lt;p&gt;Jadi, tengoklah dulu.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: Ini code selepas saya guna &lt;a href='https://clojuredocs.org/clojure.core/eduction'&gt;eduction&lt;/a&gt;. Taktahu lah sama ada ini dikira best practice. Function &lt;code&gt;register&lt;/code&gt; jadi lagi pendek, kira ok lah tu.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def user-existed-msg &amp;quot;Username/email sudah diambil. Sila daftar menggunakan username/email yang lain.&amp;quot;&amp;#41;
&amp;#40;def success-msg &amp;quot;Anda sudah berjaya mendaftar. Sila log masuk .&amp;quot;&amp;#41;

&amp;#40;defn- make-flash-msg &amp;#91;&amp;#91;errors data&amp;#93;&amp;#93;
  &amp;#40;if errors
    &amp;#91;{:errors errors :data data} data&amp;#93;
    &amp;#91;nil data&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def validate-xform
  &amp;#40;comp
   &amp;#40;map v/validate-registration&amp;#41;
   &amp;#40;map make-flash-msg&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- validate &amp;#91;form&amp;#93;
  &amp;#40;let &amp;#91;validated &amp;#40;chan 1 validate-xform&amp;#41;&amp;#93;
    &amp;#40;put! validated form&amp;#41;
    validated&amp;#41;&amp;#41;

&amp;#40;defn- find-existing-user &amp;#91;validated&amp;#93;
  &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors user :as all&amp;#93; &amp;#40;&amp;lt;! validated&amp;#41;
            already-existed &amp;#40;chan&amp;#41;&amp;#93;
        &amp;#40;if errors
          &amp;#40;put! already-existed false&amp;#41;
          &amp;#40;let &amp;#91;by-username &amp;#40;async/thread &amp;#40;find-user-by-username &amp;#40;:username user&amp;#41;&amp;#41;&amp;#41;
                by-email &amp;#40;async/thread &amp;#40;find-user-by-email &amp;#40;:email user&amp;#41;&amp;#41;&amp;#41;&amp;#93;
            &amp;#40;put! already-existed &amp;#40;boolean &amp;#40;or &amp;#40;&amp;lt;! by-username&amp;#41; &amp;#40;&amp;lt;! by-email&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;conj all already-existed&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- check-existing-user &amp;#91;user-check&amp;#93;
  &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors user already-existed :as all&amp;#93; &amp;#40;&amp;lt;! user-check&amp;#41;&amp;#93;
        &amp;#40;cond
          errors all
          &amp;#40;&amp;lt;! already-existed&amp;#41; &amp;#91;{:message user-existed-msg} user&amp;#93;
          :else all&amp;#41;&amp;#41;&amp;#41;&amp;#41;          

&amp;#40;defn- hash-user-password &amp;#91;new-user&amp;#93;
  &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors user :as all&amp;#93; &amp;#40;&amp;lt;! new-user&amp;#41;&amp;#93;
        &amp;#40;if errors
          all
          &amp;#91;errors &amp;#40;async/thread &amp;#40;update user :password hashers/derive&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- persist-user &amp;#91;new-user&amp;#93;
  &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors hashed-user :as all&amp;#93; &amp;#40;&amp;lt;! new-user&amp;#41;&amp;#93;
        &amp;#40;if errors
          all
          &amp;#40;do
            &amp;#40;println &amp;quot;Registered: &amp;quot; &amp;#40;&amp;lt;! hashed-user&amp;#41;&amp;#41;
            all&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn- make-response &amp;#91;registered&amp;#93;
  &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;errors &amp;#95;&amp;#93; &amp;#40;&amp;lt;! registered&amp;#41;&amp;#93;
        &amp;#40;if errors
          &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/daftar&amp;quot;&amp;#41;
              &amp;#40;flash errors&amp;#41;&amp;#41;
          &amp;#40;-&amp;gt; &amp;#40;redirect &amp;quot;/login&amp;quot;&amp;#41;
              &amp;#40;flash success-msg&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def register-xform
  &amp;#40;comp
   &amp;#40;map validate&amp;#41;
   &amp;#40;map find-existing-user&amp;#41;
   &amp;#40;map check-existing-user&amp;#41;
   &amp;#40;map hash-user-password&amp;#41;
   &amp;#40;map persist-user&amp;#41;
   &amp;#40;map make-response&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn register &amp;#91;{:keys &amp;#91;params&amp;#93;} respond &amp;#95;&amp;#93;
  &amp;#40;let &amp;#91;form &amp;#40;select-keys params &amp;#91;:username :email :password&amp;#93;&amp;#41;
        &amp;#91;response&amp;#93; &amp;#40;eduction register-xform &amp;#91;form&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;go &amp;#40;let &amp;#91;&amp;#91;res &amp;#95;&amp;#93; &amp;#40;alts! &amp;#91;response &amp;#40;timeout 10000&amp;#41;&amp;#93;&amp;#41;&amp;#93;
          &amp;#40;respond res&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Edit 2&lt;/strong&gt;: Saya cuba &lt;em&gt;load testing&lt;/em&gt; server kemudian membuat request untuk handler tersebut. Server selamba je bagi response. Menarik.&lt;/p&gt;
</description>
<pubDate>
Mon, 21 May 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2017-05-06-greenspun-tenth-rule/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2017-05-06-greenspun-tenth-rule/
</link>
<title>
Greenspun's Tenth Rule
</title>
<description>
 &lt;p&gt; Sebelum ini saya pernah menggunakan feature dari Java 8 untuk membuat &lt;em&gt;concurrency&lt;/em&gt; iaitu dengan menggunakan interface &lt;a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html'&gt;CompletableFuture&lt;/a&gt;. Ada suatu ketika, interface tersebut bukannya memudahkan, tapi merumitkan lagi keadaan.&lt;/p&gt;&lt;p&gt;Masalah berpunca kerana Java 8 hanya menyediakan &lt;a href='https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html'&gt;BiFunction&lt;/a&gt; yang kita boleh gunakan untuk method &lt;a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#thenCombine-java.util.concurrent.CompletionStage-java.util.function.BiFunction-'&gt;thenCombine&lt;/a&gt;. Maksudnya method tersebut hanya boleh menerima dua proses sahaja. Jika kita mahu lebih daripada dua, kita boleh menggunakan library &lt;a href='https://github.com/vavr-io/vavr'&gt;Javaslang/Vavr&lt;/a&gt; dan menggunakan interface Function3, Function4, dan sebagainya tetapi itu topik yang lain.&lt;/p&gt;&lt;p&gt;Untuk menyelesaikan proses serentak yang lebih daripada dua, Java 8 ada menyediakan method &lt;a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#allOf-java.util.concurrent.CompletableFuture...-'&gt;allOf&lt;/a&gt;. Namun, method tersebut pun ada karenahnya sendiri.&lt;/p&gt;&lt;p&gt;Yang pertama, parameter untuk &lt;strong&gt;allOf&lt;/strong&gt; ialah &lt;em&gt;variadic&lt;/em&gt;. Maksudnya method tersebut boleh menerima tak kira berapa banyak argument yang kita mahu letak, ataupun hanya letak array. Oops, tunggu dulu, kita tidak boleh meletakkan array untuk &lt;strong&gt;allOf&lt;/strong&gt; sebab CompletableFuture ialah &lt;em&gt;generic interface&lt;/em&gt;. Dalam Java kita tidak boleh membuat array untuk generic. Error tersebut dipanggil &lt;em&gt;generic array creation error&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Yang kedua, method &lt;strong&gt;allOf&lt;/strong&gt; akan return CompletableFuture dengan data type &lt;em&gt;Void&lt;/em&gt;. Ya, &lt;em&gt;VOID&lt;/em&gt;. Memang ramai yang complain pasal ini.&lt;/p&gt;&lt;p&gt;Jadi, untuk menggunakan &lt;strong&gt;allOf&lt;/strong&gt; kita perlu menghantar argument satu per satu, kemudian untuk mendapatkan &lt;em&gt;result&lt;/em&gt; kita ambik balik daripada Future masing-masing menggunakan &lt;a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#join&amp;ndash;'&gt;join&lt;/a&gt;. Sesiapa yang dah boleh agak, ya, code tersebut memang akan jadi sangatlah buruk.&lt;/p&gt;&lt;p&gt;Sekarang kita patah balik ke programming language Clojure. Di post yang sama sebelum ini, saya juga ada perkenalkan library Clojure yang menggunakan CompletableFuture dari Java 8, iaitu library &lt;a href='https://github.com/funcool/promesa'&gt;promesa&lt;/a&gt;. Saya pun intai-intai macam mana library tersebut mengendalikan masalah ini.&lt;/p&gt;&lt;p&gt;Seperti yang saya jangkakan, &lt;a href='http://funcool.github.io/promesa/latest/#working-with-collections'&gt;sangat simple, sangat mudah&lt;/a&gt;. Ya rabbi, kedua-dua isu yang saya senaraikan di atas terus hilang.&lt;/p&gt;&lt;p&gt;Secara jujurnya saya memang tepuk dahi sewaktu membaca documentation tersebut.&lt;/p&gt;&lt;p&gt;Akhir kata, jika nak dikaitkan dengan tajuk artikel ini, saya masih setuju dengan pendapat &lt;a href='https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule'&gt;Greenspun's tenth rule&lt;/a&gt; yang menyatakan:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Any sufficiently complicated C or Fortran program contains an ad-hoc,
informally-specified, bug-ridden, slow implementation of half of Common Lisp.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cuma ganti C dengan Java, dan Common Lisp dengan Clojure sebab mereka adik-beradik.&lt;/p&gt;
</description>
<pubDate>
Sat, 06 May 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2017-02-18-concurrency-model-dalam-clojure/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2017-02-18-concurrency-model-dalam-clojure/
</link>
<title>
Concurrency Model dalam Clojure
</title>
<description>
 &lt;p&gt; Selepas beberapa minggu menulis &lt;em&gt;fully asynchronous code&lt;/em&gt; dalam Java 8, terdetik hati untuk menulis &lt;em&gt;asynchronous code&lt;/em&gt; dalam programming language kegemaran saya iaitu Clojure.&lt;/p&gt;&lt;p&gt;Setelah menggodek internet, saya mendapati Clojure ada beberapa model untuk membuat &lt;em&gt;concurrency&lt;/em&gt;, antaranya:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;future/promise&lt;/li&gt;&lt;li&gt;coroutine (menggunakan library &lt;a href='https://github.com/clojure/core.async'&gt;core.async&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;actor model (menggunakan library &lt;a href='https://github.com/puniverse/pulsar'&gt;pulsar&lt;/a&gt;/quasar)&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/funcool/promesa'&gt;promesa&lt;/a&gt; (library untuk menggunakan CompletableFuture Java 8)&lt;/li&gt;&lt;li&gt;parallel workers (interop dengan Java)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Future/promise&lt;/strong&gt; sememangnya sudah ada secara &lt;em&gt;native&lt;/em&gt; dalam Clojure. Saya memang suka model yang ini terutamanya apabila Clojure menggunakan &lt;em&gt;immutable data&lt;/em&gt; secara &lt;em&gt;default&lt;/em&gt; jadi saya tidak perlu bimbang dengan &lt;em&gt;race condition&lt;/em&gt;. &lt;strong&gt;Atoms&lt;/strong&gt;, &lt;strong&gt;agents&lt;/strong&gt;, dan &lt;strong&gt;refs&lt;/strong&gt; boleh digunakan untuk menguruskan &lt;em&gt;state&lt;/em&gt;, jadi saya tidak perlu menggunakan &lt;em&gt;lock&lt;/em&gt; seperti Java 7.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Coroutine&lt;/strong&gt; adalah model yang sama digunakan dalam programming language Go. Model ini menghantar proses melalui &lt;em&gt;channel&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Actor model&lt;/strong&gt; pula digunakan dalam programming language seperti Scala dan Erlang. Saya tidak tahu sangat tentang actor model.&lt;/p&gt;&lt;p&gt;Library &lt;strong&gt;promesa&lt;/strong&gt; membolehkan programmer Clojure menulis code seperti Java 8, tetapi saya cuba elakkan kerana perlu menggunakan library luar.&lt;/p&gt;&lt;p&gt;Untuk &lt;strong&gt;parallel workers&lt;/strong&gt;, nasihat saya cuba elakkan.&lt;/p&gt;&lt;p&gt;Setelah melihat beberapa pilihan ini, saya menyangkakan pilihan cuma bergantung kepada programmer sahaja, ikut mana yang diminati. Namun, saya ada terbaca di stackoverflow yang menyatakan untuk memilih concurrency model perlulah mengikut situasi. Cuma saya masih belum nampak lagi.&lt;/p&gt;
</description>
<pubDate>
Sat, 18 Feb 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2016-02-10-etika-web-scraping/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2016-02-10-etika-web-scraping/
</link>
<title>
Etika Web Scraping
</title>
<description>
 &lt;p&gt; Baru-baru ini saya ada praktis concurrency dengan membuat web scraping menggunakan C++11. Sebelum ini saya takut untuk programming menggunakan C++ sebab terpaksa membuat memory management secara manual. Selepas membaca segala best practice untuk C++, barulah nampak yang C++11/C++14 boleh tahan elegant-nya. Yang nampak kurang sedap bila ada orang mengaku pandai C++ tapi programming macam C.&lt;/p&gt;&lt;p&gt;Berbalik ke cerita web scraping, C++ memang elegant, sehinggalah kena guna library C. Kalau tak jumpa wrapper C++ untuk library tersebut, mulut memang akan sumpah seranah waktu programming. Saya menggunakan library 'libcurl' untuk mendapatkan HTML daripada website, 'libxml2' untuk parse code HTML, dan library Boost untuk membuat concurrency.&lt;/p&gt;&lt;p&gt;'libcurl' dan 'libxml2' memang sudah ada wrapper C++, tetapi untuk educational purpose, saya cuba untuk wrap sendiri library tersebut menggunakan kaedah Resource Acquisition Is Initialization (RAII). Kaedah RAII memang selalu digunakan dalam C++ untuk memudahkan memory management.&lt;/p&gt;&lt;p&gt;Semasa cubaan awal, segalanya berjalan lancar. Boleh dapatkan code HTML daripada website, dan boleh parse HTML untuk dapatkan data yang diingini. Cabaran bermula apabila saya mula membuat concurrency. Apabila run sahaja, terus dapat segfault (segmentation fault). Kalau yang dah biasa, memang akan tahu yang segfault mesti punca daripada masalah memory.&lt;/p&gt;&lt;p&gt;Jadi, macam-macamlah yang saya ubahsuai code untuk menyelesaikan masalah. Tukar daripada kaedah menggunakan thread seperti biasa, kepada menggunakan future/promise, dan akhir sekali kepada menggunakan barrier. Selepas meletakkan barrier, saya perasan ada data yang saya dapat fetch sampai satu tahap barulah akan segfault seperti biasa.&lt;/p&gt;&lt;p&gt;Kemudian saya pun tengoklah macam mana rupa code HTML yang saya fetch tersebut. Barulah perasan yang saya dah kena block daripada website tersebut. Seperti semua sedia maklum, program C++ sememangnya laju. Jadi web scraping dengan concurrency akan jadi amat laju dan berpotensi membuatkan pemilik website tersebut berasa bimbang, lantas akan menghalang kita daripada mengakses website mereka.&lt;/p&gt;&lt;p&gt;Kesimpulannya, moral of the story untuk kisah ini ialah kita mestilah beretika semasa membuat web scraping. Seboleh-bolehnya jangan memaksa sangat website tersebut untuk handle request daripada program kita. Tak perlu laju-laju sangat pun takpe, janji dapat data yang dihajati. Kalau nak lagi elok, minta izin daripada pemilik website tersebut untuk membuat web scraping, lagi bagus.&lt;/p&gt;
</description>
<pubDate>
Wed, 10 Feb 2016 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2015-10-22-misi-mencari-ide-untuk-go/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2015-10-22-misi-mencari-ide-untuk-go/
</link>
<title>
Misi Mencari IDE Untuk Go
</title>
<description>
 &lt;blockquote&gt;&lt;p&gt; &lt;strong&gt;UPDATE&lt;/strong&gt;: Selepas beberapa hari menggunakan Atom, saya jumpa satu bug. Kalau saya ada masa untuk reproduce bug tersebut, saya akan submit issue. Jadi, untuk mengelak daripada bug tersebut, saya kembali menggunakan LiteIDE dan mendapati IDE tersebut sudah boleh 'nampak' package &lt;code&gt;appengine&lt;/code&gt; disebabkan langkah-langkah yang saya lakukan di bawah. Yay! &lt;/p&gt;&lt;p&gt;Pada masa akan datang, mungkin saya akan cuba Eclipse pulak. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Saya memilih Go sebab saya perlukan programming language yang strict. Walaupun Go masih baru, Go menepati citarasa saya, antaranya static-typing. Kelebihan static-typing language adalah supaya dapat manfaat daripada IDE, seperti code auto-completion. Disebabkan Go masih baru, support daripada IDE tidaklah setanding dengan Java. Cari punya cari, akhirnya saya jumpa text editor yang boleh menjadi IDE untuk Go, iaitu &lt;a href='https://atom.io/'&gt;Atom&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Untuk menggunakan Atom untuk Go, saya menambah package &lt;a href='https://atom.io/packages/go-plus'&gt;go-plus&lt;/a&gt;. Selepas selesai install package tersebut, saya download functionality yang diperlukan seperti &lt;code&gt;gocode&lt;/code&gt;, &lt;code&gt;gofmt&lt;/code&gt;, &lt;code&gt;goimports&lt;/code&gt;, &lt;code&gt;go vet&lt;/code&gt;, &lt;code&gt;golint&lt;/code&gt;, &lt;code&gt;go build&lt;/code&gt; dan &lt;code&gt;go test&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Sebelum ini saya menggunakan &lt;a href='https://github.com/visualfc/liteide'&gt;LiteIDE&lt;/a&gt;. LiteIDE juga bagus, tetapi disebabkan saya menggunakan cloud hosting Google App Engine, ada beberapa package yang IDE tersebut 'tak nampak'. Jadi, package &lt;code&gt;appengine&lt;/code&gt; dan yang berkaitan tidak dapat support daripada code auto-completion.&lt;/p&gt;&lt;p&gt;Untuk membuatkan Atom boleh nampak package &lt;code&gt;appengine&lt;/code&gt;, saya perlu set library path untuk &lt;code&gt;gocode&lt;/code&gt; dengan cara:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;gocode set lib-path c:\go&amp;#95;appengine\goroot\pkg\windows&amp;#95;amd64&amp;#95;appengine
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sekarang barulah ada code auto-completion untuk package &lt;code&gt;appengine&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Satu lagi masalah ialah apabila save file program Go, akan keluar error yang menyatakan &lt;code&gt;src/appengine&lt;/code&gt; tidak berada dalam &lt;code&gt;$GOPATH&lt;/code&gt; dan &lt;code&gt;$GOROOT&lt;/code&gt;. Untuk menyelesaikan masalah ini, saya membuat symlink:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mklink /J $GOPATH/src/appengine c:\go&amp;#95;appengine\goroot\src\appengine
mklink /J $GOPATH/src/appengine&amp;#95;internal c:\go&amp;#95;appengine\goroot\src\appengine&amp;#95;internal
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href='https://technet.microsoft.com/en-us/library/cc753194.aspx'&gt;mklink&lt;/a&gt; ialah command dalam Windows untuk membuat symlink. Kalau anda menggunakan operating system yang lain akan berbeza.&lt;/p&gt;&lt;p&gt;Walaupun semua steps di atas agak leceh, saya tetap berpuas hati.&lt;/p&gt;&lt;p&gt;Alternatif kepada semua cara di atas adalah dengan menggunakan package &lt;code&gt;appengine&lt;/code&gt; yang baru iaitu &lt;code&gt;google.golang.org/appengine&lt;/code&gt;. Tetapi dengan menggunakan package tersebut, saya tidak dapat code auto-completion jika menggunakan package yang berada di dalamnya seperti &lt;code&gt;google.golang.org/appengine/user&lt;/code&gt; dan &lt;code&gt;google.golang.org/appengine/log&lt;/code&gt;.&lt;/p&gt;
</description>
<pubDate>
Thu, 22 Oct 2015 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2015-10-19-pertama-kali-menggunakan-closure-sambungan/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2015-10-19-pertama-kali-menggunakan-closure-sambungan/
</link>
<title>
Pertama Kali Menggunakan 'Closure' (sambungan...)
</title>
<description>
 &lt;p&gt; Sebelum ini saya ada tunjuk bagaimana kita boleh menggunakan closure untuk menggabungkan satu function dengan function yang lain. Di bahagian paling bawah post tersebut, saya ada meminta pembaca untuk selesaikan code yang masih ada bahagian berulang. Jika anda belum mencuba dan ingin mencuba boleh lihat di &lt;a href='/blog/blog/2015/pertama-kali-menggunakan-closure.html'&gt;post ini&lt;/a&gt;. Jika tak mahu, boleh teruskan membaca untuk lihat cara saya menyelesaikannya.&lt;/p&gt;&lt;p&gt;Jadi, kenapa kena guna closure? Saje, supaya code nampak lebih elegant. Kalau boleh semua function saya nak guna closure.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/blog/images/all-closures.png&quot; alt=&quot;Write all the functions with closure!!!&quot; /&gt;&lt;/p&gt;&lt;p&gt;Baiklah. Code sebelum ini masih ada bahagian yang berulang, iaitu:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Check password length. Toggle icon accordingly. Password must be at least 
// 6 characters. 
function validatePassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}

// Check if password verification is the same with password. Toggle icon
// accordingly.
function verifyPassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41; === $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;&amp;#41; {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tetapi masalahnya condition untuk if else antara kedua-dua function tersebut adalah berlainan.&lt;/p&gt;&lt;p&gt;Dalam functional programming, semua benda kita boleh jadikan function, dan kita juga boleh passing function melalui parameter. Jadi, secara teorinya kita akan jadikan condition untuk if else tersebut sebagai function, kemudian kita akan hantar function tersebut melalui parameter untuk closure. Saya akan tunjukkan perlahan-lahan menggunakan salah satu function tersebut.&lt;/p&gt;&lt;p&gt;Function yang asal adalah seperti ini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function validatePassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sekarang kita asingkan condition tersebut ke dalam satu variable:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function validatePassword&amp;#40;&amp;#41; {
    var ok = $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6;

    if &amp;#40;ok&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dan untuk menjadikannya sebagai function, kita boleh menggunakan singleton yang akan self-invoke:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function validatePassword&amp;#40;&amp;#41; {
    var ok = &amp;#40;function&amp;#40;&amp;#41; { return $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6; }&amp;#41;&amp;#40;&amp;#41;;

    if &amp;#40;ok&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Akhirnya, kita sudah menjadikan condition tersebut sebagai sebuah function, dan kita boleh asingkan condition tersebut di luar, seperti berikut:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function&amp;#40;&amp;#41; {
    return $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6;
}

function validatePassword&amp;#40;condition&amp;#41; {
    var ok = condition&amp;#40;&amp;#41;;

    if &amp;#40;ok&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Masalah dengan cara ini ialah apabila kita hantar condition melalui parameter, kita akan invoke function validatePassword() secara automatik. Untuk tidak invoke function tersebut, kita boleh menggunakan closure:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function&amp;#40;&amp;#41; {
    return $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6;
}

function validatePassword&amp;#40;condition&amp;#41; {
    return function&amp;#40;&amp;#41; {
        var ok = condition&amp;#40;&amp;#41;;
        
        if &amp;#40;ok&amp;#41; {
            $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
            $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        } else {
            $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
            $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sekarang untuk menyelesaikan masalah code yang berulang, kita boleh abstract-kan function menggunakan keyword &lt;code&gt;this&lt;/code&gt;, seperti berikut:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function toggleIcon&amp;#40;condition&amp;#41; {
    return function&amp;#40;&amp;#41; {
        var ok = condition&amp;#40;&amp;#41;;
        var icon = $&amp;#40;this&amp;#41;;
        
        if &amp;#40;ok&amp;#41; {
            icon.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
            icon.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        } else {
            icon.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
            icon.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Kalau mahu lebih ringkas, boleh tulis seperti ini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function toggleIcon&amp;#40;ok&amp;#41; {
    return function&amp;#40;&amp;#41; {
        var icon = $&amp;#40;this&amp;#41;;
        
        if &amp;#40;ok&amp;#40;&amp;#41;&amp;#41; {
            icon.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
            icon.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        } else {
            icon.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
            icon.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: Icon boleh di-refer menggunakan &lt;code&gt;$&amp;#40;this&amp;#41;&lt;/code&gt;, dan bukannya seperti sebelum ini di mana kita menggunakan &lt;code&gt;$&amp;#40;this&amp;#41;.parent&amp;#40;&amp;#41;.next&amp;#40;&amp;#41;&lt;/code&gt; kerana function tersebut adalah callback kepada event untuk icon itu sendiri. Kalau nak tukar scope, boleh guna &lt;code&gt;bind&amp;#40;&amp;#41;&lt;/code&gt;, tapi itu dah lari dari topik.&lt;/p&gt;&lt;p&gt;Sekarang kita sudah ada closure untuk handle toggle icon.&lt;/p&gt;&lt;p&gt;Selepas refactor, akhir sekali code kita akan jadi seperti ini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Condition that states that password input must be minimum of 6 characters.
function validate&amp;#40;&amp;#41; {
    return $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6;
}

// Condition that states that password input must be the same as verify password
// input.
function verify&amp;#40;&amp;#41; {
    return $&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41; === $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;;
}

// Toggle icon according to condition. If true, shows ok. If false, shows cross.
function toggleIcon&amp;#40;ok&amp;#41; {
    return function&amp;#40;&amp;#41; {
        var icon = $&amp;#40;this&amp;#41;;
        
        if &amp;#40;ok&amp;#40;&amp;#41;&amp;#41; {
            icon.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
            icon.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        } else {
            icon.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
            icon.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        }
    };
}

// Show icon if the input is not null.
function showIcon&amp;#40;duration, callback&amp;#41; {
    return function&amp;#40;&amp;#41; {
        var input = $&amp;#40;this&amp;#41;;
        var icon = $&amp;#40;this&amp;#41;.parent&amp;#40;&amp;#41;.next&amp;#40;&amp;#41;;
        
        if &amp;#40;input.val&amp;#40;&amp;#41;.length &amp;gt; 0&amp;#41; {
            icon.show&amp;#40;duration, callback&amp;#41;;
        } else {
            icon.hide&amp;#40;duration&amp;#41;;
        }
    };
}

// Set-up events.
$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.keyup&amp;#40;showIcon&amp;#40;0, toggleIcon&amp;#40;validate&amp;#41;&amp;#41;&amp;#41;;
$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.keyup&amp;#40;showIcon&amp;#40;0, toggleIcon&amp;#40;verify&amp;#41;&amp;#41;&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bandingkan dengan code sebelum ini, yang mana lebih anda suka?&lt;/p&gt;&lt;p&gt;Kesimpulannya, closure is awesome. Seperti yang tertulis di Mozilla, kita boleh menggunakan closure sebagai 'function factory'. Anda boleh baca dengan lebih lanjut di contoh makeAdder di &lt;a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Closure'&gt;sini&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Mon, 19 Oct 2015 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
https://www.burhanloey.com/blog/posts/2015-10-18-pertama-kali-menggunakan-closure/
</guid>
<link>
https://www.burhanloey.com/blog/posts/2015-10-18-pertama-kali-menggunakan-closure/
</link>
<title>
Pertama Kali Menggunakan 'Closure'
</title>
<description>
 &lt;p&gt; Saya masih baru dalam web development dan functional programming. Semasa belajar functional programming dengan Scala, ada beberapa konsep dan teknik yang rasa-rasa macam faham, rasa-rasa macam tak, rasa-rasa tak pasti, antaranya lambda expression, map reduce, closure, dan monad.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/blog/images/i-dont-get-it.png&quot; alt=&quot;I don't get it&quot; /&gt;&lt;/p&gt;&lt;p&gt;Semuanya terjawab sedikit demi sedikit apabila saya mula menggunakan JavaScript. Dalam tutorial Scala, kita terus menggunakan simbol-simbol seperti simbol lambda, jadi kita tak beberapa nak nampak apa yang berlaku under the hood semasa menggunakan simbol lambda. Berlainan dengan JavaScript, di mana kita perlu menulis anonymous function untuk membuat map reduce tanpa menggunakan simbol lambda. Lambda expression untuk JavaScript akan ada support dalam ECMAScript 6 nanti.&lt;/p&gt;&lt;p&gt;Berbalik pada tajuk asal, antara feature dalam functional programming ialah closure. Kalau tengok pada mana-mana tutorial, contoh yang mereka beri adalah untuk menunjukkan bagaimana return function boleh akses variable dalam function yang lain. Jadi, saya pun tertanya-tanya, &quot;Apa yang special-nya?&quot;, saya boleh sahaja letak variable tersebut sebagai global dan akses dari mana-mana sahaja, betul tak? Pendapat saya itu kekal sehinggalah saya cuba membuat web development, barulah saya nampak betapa awesome-nya konsep closure ini.&lt;/p&gt;&lt;p&gt;Sebelum itu, saya nak tunjuk masalah apa yang saya nak selesaikan, iaitu sign up form. Jangan gelak, saya masih baru.&lt;/p&gt;&lt;p&gt;Sign up form yang saya nak buat simple sahaja. Ada tiga textfield untuk username, password, dan verify password. Untuk kedua-dua textfield password, saya nak display icon untuk menunjukkan sama ada input tersebut dibenarkan ataupun tidak sebaik sahaja user tulis sesuatu. Untuk textfield password, input yang saya benarkan hanyalah 6 character minimum. Untuk textfield verify password pula, input yang saya benarkan ialah input yang sama dengan password(obviously).&lt;/p&gt;&lt;p&gt;Saya menggunakan jQuery, jadi pada mulanya saya tulis code seperti ini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Check password length. Toggle icon accordingly. Password must be at least 
// 6 characters. 
function validatePassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}

// Check if password verification is the same with password. Toggle icon
// accordingly.
function verifyPassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41; === $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;&amp;#41; {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}

// Show icon if the input is not null, and then validate.
function showIconAndValidate&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt; 0&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.show&amp;#40;0, validatePassword&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.hide&amp;#40;0&amp;#41;;
    }
}

// Show icon if the input is not null, and then verify.
function showIconAndVerify&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt; 0&amp;#41; {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.show&amp;#40;0, verifyPassword&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.hide&amp;#40;0&amp;#41;;
    }
}

// Set-up events.
$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.keyup&amp;#40;showIconAndValidate&amp;#41;;
$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.keyup&amp;#40;showIconAndVerify&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Kalau sesiapa yang dah pro mungkin boleh nampak, ada bahagian yang tidak menggunakan konsep DRY(Don't-Repeat-Yourself). Sebelum membuat validation dan verification, saya check sama ada textfield ada input ataupun tidak. Kalau ada display, kalau tiada hide. Bahagian tersebut saya tulis dua kali, satu untuk textfield password, satu lagi untuk textfield verify password, jadi tak berapa bagus di situ.&lt;/p&gt;&lt;p&gt;Oleh itu, saya perlu membuat satu function untuk handle sama ada textfield ada input ataupun tidak. Tapi, tunggu dulu. Perhatikan selepas checking tersebut, saya ada membuat callback. Callback validatePassword() untuk password, callback verifyPassword() untuk verify password. Jadi, bagaimana kita nak asingkan callback tersebut? Ya, di sinilah saya menggunakan closure.&lt;/p&gt;&lt;p&gt;Code yang baru selepas refactor akan jadi seperti ini:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Check password length. Toggle icon accordingly. Password must be at least 
// 6 characters. 
function validatePassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;.length &amp;gt;= 6&amp;#41; {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}

// Check if password verification is the same with password. Toggle icon
// accordingly.
function verifyPassword&amp;#40;&amp;#41; {
    if &amp;#40;$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41; === $&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.val&amp;#40;&amp;#41;&amp;#41; {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
    } else {
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.removeClass&amp;#40;&amp;quot;glyphicon-ok&amp;quot;&amp;#41;;
        $&amp;#40;&amp;quot;#verify-password-check&amp;quot;&amp;#41;.addClass&amp;#40;&amp;quot;glyphicon-remove&amp;quot;&amp;#41;;
    }
}

// Show icon if the input is not null.
function showIcon&amp;#40;callback&amp;#41; {
    return function&amp;#40;&amp;#41; {
        var input = $&amp;#40;this&amp;#41;;
        var icon = $&amp;#40;this&amp;#41;.parent&amp;#40;&amp;#41;.next&amp;#40;&amp;#41;;
        
        if &amp;#40;input.val&amp;#40;&amp;#41;.length &amp;gt; 0&amp;#41; {
            icon.show&amp;#40;0, callback&amp;#41;;
        } else {
            icon.hide&amp;#40;0&amp;#41;;
        }
    };
}

// Set-up events.
$&amp;#40;&amp;quot;#password-input&amp;quot;&amp;#41;.keyup&amp;#40;showIcon&amp;#40;validatePassword&amp;#41;&amp;#41;;
$&amp;#40;&amp;quot;#verify-password-input&amp;quot;&amp;#41;.keyup&amp;#40;showIcon&amp;#40;verifyPassword&amp;#41;&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Saya menggunakan JavaScript traversing, iaitu &lt;code&gt;$&amp;#40;this&amp;#41;.parent&amp;#40;&amp;#41;.next&amp;#40;&amp;#41;&lt;/code&gt; untuk pilih icon. Ini tidak ada kena mengena dengan closure. Baca seterusnya untuk penjelasan mengenai closure.&lt;/p&gt;&lt;p&gt;Dalam jQuery, kita boleh passing function sebagai callback. Dalam JavaScript, jika kita letak kurungan selepas function, secara automatik kita akan invoke function tersebut. Dalam masalah saya ini, saya letak function sebagai parameter untuk callback. Jadi kalau saya tidak membuat closure, apabila saya pass function sebagai argument untuk function showIcon(), secara automatik saya invoke showIcon(), tetapi saya tak mahu begitu. Saya mahu jQuery yang invoke showIcon() bergantung kepada event yang saya tetapkan. Jadi, dengan menggunakan closure, saya boleh pass function showIcon() yang dah 'combined' dengan function yang lain.&lt;/p&gt;&lt;p&gt;Awesome kan?&lt;/p&gt;&lt;p&gt;P/S: Perhatikan function validatePassword() dan verifyPassword() ada bahagian yang berulang. Saya serahkan kepada pembaca untuk selesaikan masalah tersebut. :)&lt;/p&gt;
</description>
<pubDate>
Sun, 18 Oct 2015 00:00:00 +0800
</pubDate>
</item>
</channel>
</rss>
